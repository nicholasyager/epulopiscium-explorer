<html>

<head>
    <title>Epulopiscium Explorer</title>

    <style>
        body { margin: 0;background-color:black;}
        canvas { width: 100%; height: 100% }
        img {position:fixed;margin:auto;left:0;display:none;}
        div { margin:0; padding:0; height:100%;width:100%;}
        #stack {display:none;}
    </style>

    <script src="https://js.leapmotion.com/leap-0.6.4.min.js"></script>
    <script src="https://js.leapmotion.com/leap-plugins-0.1.10.js"></script>
    <script src="https://code.jquery.com/jquery-1.11.2.min.js"></script>
    <script src="js/rainbowvis.js"></script>
</head>
<body>
    <div id=stack style="display:none;">

    </div>
    <div id=cloud style="display:block;">

    </div>

    <script src="js/three.min.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/LeapTwoHandControls.js"></script>
    <script>

        var scene, camera, renderer;
        var mode = "3d";
        var cube;
        var controller;
        var controls, orbitcontrols;

        // Load images
        baseString = "images/raw/C_2.21_5.100";
        
        for (var i = 0 ; i < 36; i++) {
            if (i < 10) { pad = "0"; }
            else { pad= "";}

            imageString = baseString + pad + i + ".png";
            template = '<img id='+i+' src="'+imageString+'"/>';
            $("#stack").append(template);
        }

        // Sets up the scene and intializes the render.
        function init() {
        
            // Create the scene

            scene = new THREE.Scene();
            var WIDTH = window.innerWidth,
                HEIGHT = window.innerHeight;

            // Add the renderer to the DOM
            renderer = new THREE.WebGLRenderer({antialias:true});
            renderer.setSize(WIDTH,HEIGHT);
            document.getElementById('cloud').appendChild(renderer.domElement);

            // Initialize the camera
            camera = new THREE.PerspectiveCamera(45, WIDTH/HEIGHT, 0.1, 20000);
            camera.position.set(0,0,10);
            scene.add(camera);

            // Resize listener.
            window.addEventListener('resize', function() {
                var WIDTH = window.innerWidth,
                    HEIGHT = window.innerHeight;
                renderer.setSize(WIDTH,HEIGHT);
                camera.aspect = WIDTH/HEIGHT;
                camera.updateProjectionMatrix();
            });

            // LEAP Initialization

            controller = new Leap.Controller({enableGestures: true});

            var indexBuffer=1;

            controller.loop( function(frame) {
                if (mode == "stack") {
                if (frame.hands.length >= 1){
                    hand = frame.hands[0];

                    if (hand.pinchStrength >= 0.75){
                    index = Math.floor(((hand.palmPosition[1] - 150)/150)*35);
                    if (index > 35) {index = 35;}
                    if (index < 0) {index = 0;}
                    
                    $("#"+indexBuffer).css("display","none");
                    $("#"+index).css("display","block");
                    indexBuffer = index;
                    }
                }
                }
            });

            controller.connect();

            controller.on("gesture", function(gesture) {
                switch (gesture.type) {
                    case "swipe":
                        if (gesture.direction[0] > 0){
                            // right swipe
                            mode = "3d"
                            console.log("RIGHT SWIPE!");                                
                            document.getElementById('stack').style.display="none";
                            document.getElementById('cloud').style.display="block";

                        } else {
                            mode = "stack";
                            console.log("LEFT SWIPE!");
                            document.getElementById('cloud').style.display="none";
                            document.getElementById('stack').style.display="block";
                        }
                        break;
                }
            });

            // Add Controls
            controls = new THREE.LeapTwoHandControls(camera, controller, scene);


            controls.translationSpeed   = 0.1;
            controls.translationDecay   = 0.25;
            controls.scaleDecay         = 0.5;
            controls.rotationSlerp      = 1;
            controls.rotationSpeed      = 2;
            controls.pinchThreshold     = 0.8;
            controls.transSmoothing     = 0.5;
            controls.rotationSmoothing  = 0.2;

            orbitcontrols = new THREE.OrbitControls(camera, renderer.domElement);
        }

        function addChromosomes() {

            var numberOfChromosomes = 2000;

            $.getJSON( "data/points.json", function( data ) {
                xStats = average(data.x);
                yStats = average(data.y);
                zStats = average(data.z);

                xMax = arrayMax(data.x);
                xMin = arrayMin(data.x);

                yMax = arrayMax(data.y);
                yMin = arrayMin(data.y);

                zMax = arrayMax(data.z);
                zMin = arrayMin(data.z);

                distMin = arrayMin(data.dist);
                distMax = arrayMax(data.dist);


                rainbow = new Rainbow();
                rainbow.setNumberRange(distMin, 50);

                var xCorrection = ((xMax+xMin)/2 - xMin)/(xMax - xMin);
                var yCorrection = ((yMax+yMin)/2 - yMin)/(yMax - yMin);
                var zCorrection = ((zMax+zMin)/2 - zMin)/(zMax - zMin);
      

                var geometry = new THREE.Geometry();

                var xMean = yMean = zMean = 0;

                for (var iteration = 0; iteration < numberOfChromosomes; iteration++){
                    var index = Math.floor(Math.random()* data.x.length );
                    if (data.dist[index] < 50) {


                        var x =(((data.x[index]-xMin)/(xMax-xMin)) - xCorrection) * 30;
                        var y =(((data.z[index]-zMin)/(zMax-zMin)) - zCorrection) * 10;
                        var z =(((data.y[index]-yMin)/(yMax-yMin)) - yCorrection) * 30;

                        var sphere = new THREE.SphereGeometry( 0.075, 6, 6 );
                        chromosomeColor = new THREE.Color("#"+rainbow.colourAt(data.dist[index]));
                        var chromosome =  new THREE.Mesh( sphere, new THREE.MeshBasicMaterial( { color:chromosomeColor } ) );
                        scene.add( chromosome);
                        chromosome.position.x=x;
                        chromosome.position.y=y;
                        chromosome.position.z=z;

                        xMean += x;
                        yMean += y;
                        zMean += z;

                    }
                }
                xMean = xMean / numberOfChromosomes;
                yMean = yMean / numberOfChromosomes;
                zMean = zMean / numberOfChromosomes;
    
                var geometry = new THREE.BoxGeometry( 0.01, 0.01, 0.01 );
                var material = new THREE.MeshBasicMaterial( { color: 0xffffff } );
                cube = new THREE.Mesh( geometry, material );
                cube.position.set(xMean, yMean, zMean);
                scene.add(cube);
                console.log(xMean);

                camera.lookAt(cube.position);
            });

        }

        function handStateFromHistory(hand, historySamples) {
            if(hand.grabStrength == 1) return "closed";
            else if (hand.grabStrength == 0) return "open";
            else {
                var sum = 0
                for(var s = 0; s < historySamples; s++){
                    var oldHand = controller.frame(s).hand(hand.id)
                    if(!oldHand.valid) break;
                    sum += oldHand.grabStrength
                }
                var avg = sum/s;
                if(hand.grabStrength - avg < 0) return "opening";
                else if (hand.grabStrength > 0) return "closing";
            }
            return"not detected";
        }

        average = function(a){
            var r = {mean: 0, variance: 0, deviation: 0}, t = a.length;
            for(var m, s = 0, l = t; l--; s += a[l]);
            for(m = r.mean = s / t, l = t, s = 0; l--; s += Math.pow(a[l] - m, 2));
            return r.deviation = Math.sqrt(r.variance = s / t), r;
        }

        function arrayMin(arr) {
            var len = arr.length, min = Infinity;
            while (len--) {
                if (arr[len] < min) {
                    min = arr[len];
                }
            }
            return min;
        };

        function arrayMax(arr) {
            var len = arr.length, max = -Infinity;
                while (len--) {
                    if (arr[len] > max) {
                        max = arr[len];
                    }
                }
            return max;
        };


        init();
        addChromosomes();

        function render() {
            requestAnimationFrame( render );
            controls.update();
            orbitcontrols.update();
            renderer.render( scene, camera );
        }
        render();

        var output = document.getElementById('output');

        var startVector = new THREE.Vector3(0,0,0);
        var startDistance = 0;
        var distance = 4;

        /*
        var controller  = Leap.loop({enableGestures: true}, function (frame) {

            // Initialize gestures
            if(frame.valid && frame.gestures.length > 0){
                frame.gestures.forEach(function(gesture) {
                    switch (gesture.type) {
                        case "swipe":
                            if (gesture.direction[0] > 0){
                                // right swipe
                                mode = "3d"
                                console.log("RIGHT SWIPE!");                                
                                document.getElementById('stack').style.display="hidden";
                                document.getElementById('cloud').style.display="block";

                            } else {
                                mode = "stack";
                                console.log("LEFT SWIPE!");
                                document.getElementById('cloud').style.display="hidden";
                                document.getElementById('stack').style.display="block";
                            }
                            break;
                    }
                });
            }

            if (mode == "3d"){
            if (frame.hands.length == 1) {

                startDistance = 0;

                hand = frame.hands[0];


                if (hand.type == "right") {

                    if (handStateFromHistory(hand, 10) == "closing") {
                        startVector = new THREE.Vector3(hand.palmPosition[0]/50,
                                                        hand.palmPosition[1]/75,
                                                        hand.palmPosition[2]/75);
                        startTheta = Math.acos(startVector.z);

                    } else if  (handStateFromHistory(hand, 10) == "closed" && hand.timeVisible > 0.25){

                        newVector =  new THREE.Vector3(hand.stabilizedPalmPosition[0]/50,
                                                       hand.stabilizedPalmPosition[1]/75,
                                                       hand.stabilizedPalmPosition[2]/75);

                        startVectorZX = new THREE.Vector2(startVector.z, startVector.x);
                        newVectorZX = new THREE.Vector2(newVector.z, newVector.x);

                        startVectorZY = new THREE.Vector2(startVector.z, startVector.y);
                        newVectorZY = new THREE.Vector2(newVector.z, newVector.y);

                        startVectorXY = new THREE.Vector2(startVector.x, startVector.y);
                        newVectorXY = new THREE.Vector2(newVector.x, newVector.y);



                        theta = Math.acos(startVectorZX.normalize().dot(newVectorZX.normalize()));
                        phi = Math.acos(startVectorZY.normalize().dot(newVectorZY.normalize()));
                        gamma = Math.acos(startVectorZY.normalize().dot(newVectorZY.normalize()));
                        if (newVector.x - startVector.x > 0) {theta = -1 * theta;}
                        if (newVector.y - startVector.y < 0) {phi = -1 * phi;}
                        if (newVector.z - startVector.z > 0) {gamma = -1 * gamma;}
                        
                        if (!isNaN(theta) && !isNaN(phi) && !isNaN(gamma)){
                            camera.position.applyAxisAngle(new THREE.Vector3(0,1,0), theta);
                            camera.position.applyAxisAngle(new THREE.Vector3(1,0,0), phi);
                            camera.position.applyAxisAngle(new THREE.Vector3(0,0,1), gamma);
                        }
                        // Reorient to face origin.
                        camera.lookAt(cube.position);

                        startVector = newVector;

                    }
                } else {

                     if (handStateFromHistory(hand, 10) == "closing") {
                        startVector = new THREE.Vector3(hand.palmPosition[0]/50,
                                                        hand.palmPosition[1]/75,
                                                        hand.palmPosition[2]/75);

                    } else if  (handStateFromHistory(hand, 10) == "closed" && hand.timeVisible > 0.25){

                        newVector =  new THREE.Vector3(hand.stabilizedPalmPosition[0]/50,
                                                       hand.stabilizedPalmPosition[1]/75,
                                                       hand.stabilizedPalmPosition[2]/75);


                        //origin = origin.add(startVector.sub(newVector));

                        // Reorient to face origin.
                        //camera.lookAt(origin);

                        startVector = newVector;


                    }
                }
            

            } else if (frame.hands.length  == 2) {
                handOne = frame.hands[0];
                handTwo = frame.hands[1];

                handOneVector = new THREE.Vector3(handOne.palmPosition[0]/50,
                                                  handOne.palmPosition[1]/75,
                                                  handOne.palmPosition[2]/75);

                handTwoVector = new THREE.Vector3(handTwo.palmPosition[0]/50,
                                                  handTwo.palmPosition[1]/75,
                                                  handTwo.palmPosition[2]/75);

                newDistance = handOneVector.distanceTo(handTwoVector);

                if (handOne.timeVisible >= 0.25 && handTwo.timeVisible >= 0.25 && handOne.grabStrength > 0.5 && handTwo.grabStrength > 0.5) {
                    distance -= newDistance - startDistance; 

                    if (distance < 0.5) {distance = 0.5;}

                    console.log(distance);

                    camera.position.setLength(distance);
                
                }

                startDistance = newDistance;                    


            } else {
                startDistance = 0;
            }
            } else {
                // Stack controls;
            }
            --!>
        });
    */
    </script>

</body>


</html>
